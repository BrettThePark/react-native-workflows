{"version":3,"sources":["parseTextForJSX.ts"],"names":["tagRegex","beforeTagRegex","parseNextChunk","textToParse","tagMatch","exec","beforeTagMatch","tag","text","nextIndex","length","groups","result","substring","parseTextForJSX","parseableText"],"mappings":"woEAgBA,GAAMA,CAAAA,QAAQ,aAAG,oCAAH,gBAAd,CAIA,GAAMC,CAAAA,cAAc,aAAG,iCAAH,UAApB,CAKA,GAAMC,CAAAA,cAAc,CAAG,QAAjBA,CAAAA,cAAiB,CAACC,WAAD,CAA0C,CAC7D,GAAMC,CAAAA,QAAQ,CAAGJ,QAAQ,CAACK,IAAT,CAAcF,WAAd,CAAjB,CACA,GAAMG,CAAAA,cAAc,CAAGL,cAAc,CAACI,IAAf,CAAoBF,WAApB,CAAvB,CAEA,GAAII,CAAAA,GAAG,CAAG,MAAV,CACA,GAAIC,CAAAA,IAAI,CAAG,EAAX,CACA,GAAIC,CAAAA,SAAS,CAAGN,WAAW,CAACO,MAA5B,CAEA,GAAIN,QAAJ,CAAc,mFACVG,GAAG,yCAAGH,QAAQ,CAACO,MAAZ,2CAAG,iBAAiBJ,GAApB,6DAA2B,EAA9B,CACAC,IAAI,2CAAGJ,QAAQ,CAACO,MAAZ,4CAAG,kBAAiBH,IAApB,+DAA4B,EAAhC,CACAC,SAAS,CAAGL,QAAQ,CAAC,CAAD,CAAR,CAAYM,MAAxB,CACH,CAJD,IAIO,IAAIJ,cAAJ,CAAoB,kDACvBE,IAAI,gDAAGF,cAAc,CAACK,MAAlB,iDAAG,uBAAuBH,IAA1B,+DAAkC,EAAtC,CACAC,SAAS,CAAGH,cAAc,CAAC,CAAD,CAAd,CAAkBI,MAA9B,CACH,CAHM,IAGA,CACHF,IAAI,CAAGL,WAAP,CACH,CAED,GAAMS,CAAAA,MAAM,CAAG,CAAC,CAAEL,GAAG,CAAHA,GAAF,CAAOC,IAAI,CAAJA,IAAP,CAAD,CAAf,CACA,GAAIL,WAAW,CAACO,MAAZ,CAAqB,CAAzB,CAA4B,CACxB,gBAAWE,MAAX,iCAAsBV,cAAc,CAACC,WAAW,CAACU,SAAZ,CAAsBJ,SAAtB,CAAD,CAApC,GACH,CACD,MAAOG,CAAAA,MAAP,CACH,CAxBD,CA0BO,GAAME,CAAAA,eAAe,CAAG,QAAlBA,CAAAA,eAAkB,CAACC,aAAD,QAA4Cb,CAAAA,cAAc,CAACa,aAAD,CAA1D,EAAxB,C","sourcesContent":["/**\n * @packageDocumentation\n * @module Helpers\n */\n\n/**\n * A string accompanied by a style tag.\n */\nexport type ParsedJSXText = {\n    tag: string;\n    text: string;\n};\n\n/**\n * @ignore\n */\nconst tagRegex = /^<(?<tag>\\w+)>(?<text>.+?)<\\/\\k<tag>>/s;\n/**\n * @ignore\n */\nconst beforeTagRegex = /^(?<text>.+?)(?=<\\w+?>)/s;\n\n/**\n * Creates an array of [[ParsedJSXText]] from a string, separating the string into substrings accompanied by a tag.\n */\nconst parseNextChunk = (textToParse: string): ParsedJSXText[] => {\n    const tagMatch = tagRegex.exec(textToParse);\n    const beforeTagMatch = beforeTagRegex.exec(textToParse);\n\n    let tag = 'none';\n    let text = '';\n    let nextIndex = textToParse.length;\n\n    if (tagMatch) {\n        tag = tagMatch.groups?.tag ?? '';\n        text = tagMatch.groups?.text ?? '';\n        nextIndex = tagMatch[0].length;\n    } else if (beforeTagMatch) {\n        text = beforeTagMatch.groups?.text ?? '';\n        nextIndex = beforeTagMatch[0].length;\n    } else {\n        text = textToParse;\n    }\n\n    const result = [{ tag, text }];\n    if (textToParse.length > 0) {\n        return [...result, ...parseNextChunk(textToParse.substring(nextIndex))];\n    }\n    return result;\n};\n\nexport const parseTextForJSX = (parseableText: string): ParsedJSXText[] => parseNextChunk(parseableText);\n"]}